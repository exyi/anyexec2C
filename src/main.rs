extern crate base64;
extern crate argparse;

use std::io::*;
use std::fs::*;
use std::process::{Command, exit};
use std::path::Path;
use std::env;

mod c_code;

use c_code::*;
use argparse::{ArgumentParser, StoreTrue, List, StoreOption};

struct CmdArgs {
    comment_files: Vec<String>,
    build_file: Option<String>,
    asset_files: Vec<String>,
    exec_file: Option<String>,
    enable_error_checks: bool,
}

fn parse_args() -> CmdArgs {
    let mut args = CmdArgs {
        enable_error_checks: false,
        comment_files: Vec::new(),
        build_file: None,
        asset_files: Vec::new(),
        exec_file: None,
    };

    {
        let mut ap = ArgumentParser::new();
        ap.set_description("Generate C source code with binary payload.");
        ap.refer(&mut args.enable_error_checks).add_option(
            &["-e", "--with-error-checks"],
            StoreTrue,
            "Add error checks to the launcher source code. Results are delivered via exit code.",
        );
        ap.refer(&mut args.comment_files).add_option(
            &["-c", "--comment"],
            List,
            "Original source code files attached as comments inside the generated file",
        );
        ap.refer(&mut args.build_file).add_option(
            &["-b", "--build"],
            StoreOption,
            "Compile and exec this file. It also attaches it as a comment file. Can't be used together with --exec",
        );
        ap.refer(&mut args.asset_files).add_option(
            &["-a", "--asset"],
            List,
            "File that will be just saved alongside your executable. Its name will stay the same.",
        );
        ap.refer(&mut args.exec_file).add_option(
            &["-x", "--exec"],
            StoreOption,
            "Deliver and execute this file. Can't be used together with --build",
        );
        ap.parse_args_or_exit();
    }


    // check if exec and build correctlly set
    if args.build_file.is_some() == args.exec_file.is_some() {
        if args.build_file.is_some() {
            println!("Can't have build and exec together.");
        } else {
            println!("Nothing to execute.");
        }
        exit(1);
    }

    // add build file to comment files
    if args.build_file.is_some() {
        let c = args.build_file.take().unwrap();
        args.comment_files.push(c.clone());
        args.build_file = Some(c);
    }

    args
}

fn main() {
    let mut args = parse_args();
    // write information header
    println!("// This source code was generated by anyexec2c.");
    println!("// Link: https://github.com/exyi/anyexec2C");
    println!();

    // write the actual source code as C comments
    for f in args.comment_files {
        let path = Path::new(&f);
        if !path.exists() {
            eprintln!("{} - file does not exist!", f);
            exit(1);
        }

        println!("// ==============================", );
        println!("// {}", f);
        println!("// ==============================");
        let f = BufReader::new(File::open(&f).expect(&format!(
            "Could not find comment file - {}",
            &f
        )));
        for l in f.lines() {
            println!("// {}", l.unwrap());
        }
        println!();
    }

    // build executable
    if let Some(build_file) = args.build_file {
        let extension = build_file.clone();
        let extension = extension.split(".").last();
        if extension.is_none() {
            eprintln!("Failed to split extension off build file name");
            exit(1);
        }
        let extension = extension.unwrap();
        args.exec_file = match extension {
            // D lang
            "d" => {
                compile(&format!("dmd -O {} -of=a.out -od={}",
                                 build_file,
                                 env::temp_dir().as_os_str().to_str().expect("TMP dir has non-unicode name!")
                ), "a.out")
            }
            "go" => {
                compile(&format!("go build -o a.out {}", build_file), "a.out")
            }
            "rs" => {
                let program_name = bash_command("cat Cargo.toml | grep \"name\" | sed 's/.*\"\\(.*\\)\"/\\1/'");
                let pn = program_name.trim();
                compile(&format!("cargo build -Z unstable-options --release --target x86_64-unknown-linux-musl --out-dir ."), pn)
            }
            _ => {
                eprintln!("File extension not recognized! Can't build!");
                exit(1);
            }
        };
    }

    // read executable
    let exec_file = args.exec_file.expect("No executable file supplied!");
    bash_command(&format!("strip {}", exec_file));      // remove debug symbols from the binary
    let mut f = File::open(&exec_file).unwrap();
    let mut executable = Vec::new();
    f.read_to_end(&mut executable).unwrap();

    // insert libs and the main executable
    print!("{}", str::replace(C_LIBS_AND_EXECUTABLE, "%%EXECUTABLE%%", &base64::encode(&executable)));

    let main = if args.enable_error_checks {
        C_MAIN_WITH_CHECKS
    } else {
        C_MAIN_SIMPLE
    };


    // insert main and assets
    let mut assets_extractor = String::new();
    for file in args.asset_files {
        let mut f = File::open(&file).unwrap();
        let mut asset = Vec::new();
        f.read_to_end(&mut asset).unwrap();
        assets_extractor.push_str(&format!("extract(\"{}\", \"{}\");", &base64::encode(&asset), &file));
    }

    print!("{}", str::replace(main, "%%ASSETS%%", &assets_extractor));
}


/// Takes `&str`, executes it. Expected executable result is file called `a.out`
fn compile(build_command: &str, result_binary: &str) -> Option<String> {
    // assemble command
    let mut parts = build_command.split(" ");
    let mut command = Command::new(parts.next().unwrap());
    let args: Vec<&str> = parts.collect();
    let command = command.args(args);

    // execute
    let output = command.output()
        .expect(&format!("Failed to execute compiler. Command:\n{}", build_command));

    // Check output and print it to stderr...
    {
        let stderr = ::std::io::stderr();
        let mut handle = stderr.lock();
        let _result = handle.write_all(&output.stdout);
        let _result = handle.write_all(&output.stderr);
    }

    // check status
    if !output.status.success() {
        eprintln!("\nCompilation error!");
        exit(1);
    }

    // Check for compiled binary existence
    let path = Path::new(result_binary);
    if !path.exists() {
        eprintln!("Couldn't find compiled binary... Failed.");
        exit(1);
    }

    Some(String::from(result_binary))
}

fn bash_command(cmd: &str) -> String {
    // assemble command
    let mut command = Command::new("bash");
    let command = command.args(&["-c", cmd]);

    // execute
    let output = command.output()
        .expect(&format!("Failed to execute bash command. Command:\n{}", cmd));

    // Print stderr to stderr...
    {
        let stderr = ::std::io::stderr();
        let mut handle = stderr.lock();
        let _result = handle.write_all(&output.stderr);
    }

    // check status
    if !output.status.success() {
        eprintln!("\nBash command execution error!");
        exit(1);
    }

    String::from_utf8(output.stdout).expect("Could not parse command output - invalid UTF8")
}


#[test]
fn test_bash_command() {
    assert_eq!(bash_command("echo \"ahoj\" | cat"), "ahoj\n");
    assert_eq!(bash_command("cat Cargo.toml | grep \"name\" | sed 's/.*\"\\(.*\\)\"/\\1/'"), "anyexec2c\n");
}
