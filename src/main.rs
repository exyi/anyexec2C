extern crate base64;
extern crate argparse;

use std::io::*;
use std::fs::*;
use std::process::{Command, exit};
use std::path::Path;
use std::env;

mod c_code;
mod csharp_code;

use c_code::*;
// use csharp_code;
use argparse::{ArgumentParser, StoreTrue, List, StoreOption};

enum OutputLanguage {
    C,
    CSharp
}


struct CmdArgs {
    comment_files: Vec<String>,
    build_file: Option<String>,
    asset_files: Vec<String>,
    exec_file: Option<String>,
    enable_error_checks: bool,
    target: OutputLanguage,
}

fn parse_args() -> CmdArgs {
    let mut args = CmdArgs {
        enable_error_checks: false,
        comment_files: Vec::new(),
        build_file: None,
        asset_files: Vec::new(),
        exec_file: None,
        target: OutputLanguage::C
    };

    let mut target = "c".to_owned();
    {
        let mut ap = ArgumentParser::new();
        ap.set_description("Generate C source code with binary payload.");
        ap.refer(&mut args.enable_error_checks).add_option(
            &["-e", "--with-error-checks"],
            StoreTrue,
            "Add error checks to the launcher source code. Results are delivered via exit code.",
        );
        ap.refer(&mut args.comment_files).add_option(
            &["-c", "--comment"],
            List,
            "Original source code files attached as comments inside the generated file",
        );
        ap.refer(&mut args.build_file).add_option(
            &["-b", "--build"],
            StoreOption,
            "Compile and exec this file. It also attaches it as a comment file. Can't be used together with --exec",
        );
        ap.refer(&mut args.asset_files).add_option(
            &["-a", "--asset"],
            List,
            "File that will be just saved alongside your executable. Its name will stay the same.",
        );
        ap.refer(&mut args.exec_file).add_option(
            &["-x", "--exec"],
            StoreOption,
            "Deliver anlis file. Can't be used together with --build",
        );
        ap.refer(&mut target).add_option(
            &["-t", "--target"],
            argparse::Store,
            "Output Language"
        );
        ap.parse_args_or_exit();

    }
    args.target =
        match target.to_lowercase().as_str() {
            "c" => OutputLanguage::C,
            "csharp" | "c#" => OutputLanguage::CSharp,
            _ => {
                eprintln!("Unsupported target type '{}'.", target);
                exit(1);
            }
        };


    // check if exec and build correctly set
    if args.build_file.is_some() == args.exec_file.is_some() {
        if args.build_file.is_some() {
            println!("Can't have build and exec together.");
        } else {
            println!("Nothing to execute.");
        }
        exit(1);
    }

    // add build file to comment files
    if args.build_file.is_some() {
        let c = args.build_file.take().unwrap();
        args.comment_files.push(c.clone());
        args.build_file = Some(c);
    }

    args
}

fn main() {
    let mut args = parse_args();
    // write information header
    println!("// This source code was generated by anyexec2c.");
    println!("// Link: https://github.com/exyi/anyexec2C");
    println!();

    // write the actual source code as C comments
    for f in args.comment_files {
        let path = Path::new(&f);
        if !path.exists() {
            eprintln!("{} - file does not exist!", f);
            exit(1);
        }

        println!("// ==============================", );
        println!("// {}", f);
        println!("// ==============================");
        let f = BufReader::new(File::open(&f).expect(&format!(
            "Could not find comment file - {}",
            &f
        )));
        for l in f.lines() {
            println!("// {}", l.unwrap());
        }
        println!();
    }

    // build executable
    if let Some(build_file) = args.build_file {
        let extension = build_file.clone();
        let extension = extension.split(".").last();
        if extension.is_none() {
            eprintln!("Failed to split extension off build file name");
            exit(1);
        }
        let extension = extension.unwrap();
        args.exec_file = match extension {
            // D lang
            "d" => {
                compile(&format!("dmd -O {} -of=a.out -od={}",
                                 build_file,
                                 env::temp_dir().as_os_str().to_str().expect("TMP dir has non-unicode name!")
                ), "a.out")
            }
            "go" => {
                compile(&format!("go build -o a.out {}", build_file), "a.out")
            }
            "c" => {
                compile(&format!("gcc -o a.out {} -O3 -Wall", build_file), "a.out")
            }
            "cpp" => {
                compile(&format!("g++ -o a.out {} -O3 -std=c++17 -Wall", build_file), "a.out")
            }
            "rs" => {
                let program_name = bash_command("cat Cargo.toml | grep \"name\" | sed 's/.*\"\\(.*\\)\"/\\1/'");
                let pn = program_name.trim();
                compile(&format!("cargo build -Z unstable-options --release --target x86_64-unknown-linux-musl --out-dir ."), pn)
            }
            extension => {
                eprintln!("File extension '{}' not recognized! Can't build!", extension);
                exit(1);
            }
        };
    }

    // read executable
    let exec_file = args.exec_file.expect("No executable file supplied!");
    let mut f = File::open(&exec_file).unwrap();
    let mut executable = Vec::new();
    f.read_to_end(&mut executable).unwrap();

    let part1 =
        match args.target {
            OutputLanguage::C => C_LIBS_AND_EXECUTABLE,
            OutputLanguage::CSharp =>
                csharp_code::PART1
        };

    // insert libs and the main executable
    print!("{}", str::replace(part1, "%%EXECUTABLE%%", &base64::encode(&executable)));

    let main =
        match args.target {
            OutputLanguage::C =>
                if args.enable_error_checks {
                    C_MAIN_WITH_CHECKS
                } else {
                    C_MAIN_SIMPLE
                },
            OutputLanguage::CSharp =>
                csharp_code::MAIN
        };


    // insert main and assets
    let mut assets_extractor = String::new();
    for file in args.asset_files {
        let mut f = File::open(&file).unwrap();
        let mut asset = Vec::new();
        f.read_to_end(&mut asset).unwrap();
        assets_extractor.push_str(&format!("extract(\"{}\", \"{}\");", &base64::encode(&asset), &file));
    }

    print!("{}", str::replace(main, "%%ASSETS%%", &assets_extractor));
}


/// Takes `&str`, executes it. Expected executable result is file called `a.out`
fn compile(build_command: &str, result_binary: &str) -> Option<String> {
    // assemble command
    let mut parts = build_command.split(" ");
    let mut command = Command::new(parts.next().unwrap());
    let args: Vec<&str> = parts.collect();
    let command = command.args(args);

    // execute
    let output = command.output()
        .expect(&format!("Failed to execute compiler. Command:\n{}", build_command));

    // Check output and print it to stderr...
    {
        let stderr = ::std::io::stderr();
        let mut handle = stderr.lock();
        let _result = handle.write_all(&output.stdout);
        let _result = handle.write_all(&output.stderr);
    }

    // check status
    if !output.status.success() {
        eprintln!("\nCompilation error!");
        exit(1);
    }

    // Check for compiled binary existence
    let path = Path::new(result_binary);
    if !path.exists() {
        eprintln!("Couldn't find compiled binary... Failed.");
        exit(1);
    }

    bash_command(&format!("strip {}", result_binary));      // remove debug symbols from the binary

    Some(String::from(result_binary))
}

fn bash_command(cmd: &str) -> String {
    // assemble command
    let mut command = Command::new("bash");
    let command = command.args(&["-c", cmd]);

    // execute
    let output = command.output()
        .expect(&format!("Failed to execute bash command. Command:\n{}", cmd));

    // Print stderr to stderr...
    {
        let stderr = ::std::io::stderr();
        let mut handle = stderr.lock();
        let _result = handle.write_all(&output.stderr);
    }

    // check status
    if !output.status.success() {
        eprintln!("\nBash command execution error!");
        exit(1);
    }

    String::from_utf8(output.stdout).expect("Could not parse command output - invalid UTF8")
}


#[test]
fn test_bash_command() {
    assert_eq!(bash_command("echo \"ahoj\" | cat"), "ahoj\n");
    assert_eq!(bash_command("cat Cargo.toml | grep \"name\" | sed 's/.*\"\\(.*\\)\"/\\1/'"), "anyexec2c\n");
}
