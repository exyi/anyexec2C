extern crate base64;
extern crate argparse;

use std::io::*;
use std::fs::*;

mod c_code;
use c_code::*;
use argparse::{ArgumentParser, StoreTrue, List};

struct CmdArgs {
    comment_files: Vec<String>,
    with_error_checks: bool,
}

fn parse_args() -> CmdArgs {
    let mut args = CmdArgs {
        with_error_checks: false,
        comment_files: Vec::new(),
    };

    {
        let mut ap = ArgumentParser::new();
        ap.set_description("Generate C source code with binary payload.");
        ap.refer(&mut args.with_error_checks).add_option(
            &["-e", "--with-error-checks"],
            StoreTrue,
            "Exit code errors.",
        );
        ap.refer(&mut args.comment_files).add_argument(
            "arguments",
            List,
            "Original source code files",
        );

        ap.parse_args_or_exit();
    }
    args
}

fn main() {
    let args = parse_args();
    let mut buffer = Vec::new();
    stdin().read_to_end(&mut buffer).expect(
        "Could not read stdin",
    );

    // write information header
    println!("// This source code was generated by anyexec2c.");
    println!("// Link: https://github.com/exyi/anyexec2C");
    println!();

    // write the actual source code as C comments
    for f in args.comment_files {
        println!("// ==============================", );
        println!("// {}", f);
        println!("// ==============================");
        let f = BufReader::new(File::open(&f).expect(&format!(
            "Could not find comment file - {}",
            &f
        )));
        for l in f.lines() {
            println!("// {}", l.unwrap());
        }
        println!();
    }

    // Create the actually working part of the C code
    stdout().write(C_HEADER).unwrap();
    print!("{}", base64::encode(&buffer));
    stdout().write(C_LIB_FUNCTIONS).unwrap();

    stdout()
        .write(if args.with_error_checks {
            C_MAIN_WITH_CHECKS
        } else {
            C_MAIN_SIMPLE
        })
        .unwrap();
}
